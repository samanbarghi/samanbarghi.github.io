<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Generate C interface from C++ source code using Clang libtooling | Saman Barghi</title><meta name=keywords content="Clang,libtooling,LLVM,C,C++,source code generation,source to source translation"><meta name=description content="Using Clang libtooling for LLVM to generate C interface from C++ source code."><meta name=author content="Saman Barghi"><link rel=canonical href=http://samanbarghi.com/post/using-clang-libtooling-to-generate-c-interface-from-c++-source-code/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://samanbarghi.com/images/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://samanbarghi.com/images/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://samanbarghi.com/images/favicon/favicon-32x32.png><link rel=apple-touch-icon href=http://samanbarghi.com/images/favicon/apple-touch-icon.png><link rel=mask-icon href=http://samanbarghi.com/images/favicon/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-48282777-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Generate C interface from C++ source code using Clang libtooling"><meta property="og:description" content="Using Clang libtooling for LLVM to generate C interface from C++ source code."><meta property="og:type" content="article"><meta property="og:url" content="http://samanbarghi.com/post/using-clang-libtooling-to-generate-c-interface-from-c++-source-code/"><meta property="og:image" content="http://samanbarghi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2016-12-06T10:40:49-05:00"><meta property="article:modified_time" content="2016-12-06T10:40:49-05:00"><meta property="og:site_name" content="Saman Barghi"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://samanbarghi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Generate C interface from C++ source code using Clang libtooling"><meta name=twitter:description content="Using Clang libtooling for LLVM to generate C interface from C++ source code."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://samanbarghi.com/post/"},{"@type":"ListItem","position":2,"name":"Generate C interface from C++ source code using Clang libtooling","item":"http://samanbarghi.com/post/using-clang-libtooling-to-generate-c-interface-from-c++-source-code/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Generate C interface from C++ source code using Clang libtooling","name":"Generate C interface from C\u002b\u002b source code using Clang libtooling","description":"Using Clang libtooling for LLVM to generate C interface from C++ source code.","keywords":["Clang","libtooling","LLVM","C","C++","source code generation","source to source translation"],"articleBody":"I developed a concurrent user-thread library using C++, and was looking for a way to provide a C interface and make the functionality available in C. In order to achieve this goal, I started writting a C wrapper interface manually where each public method of a class is mapped to a function in C with the class name followed by the function name. Also, constructors are mapped to class name followed by _create and destructors are mapped to the class name followed by _destory. To create an object, memory is allocated using new in C++ and the pointer is casted to a struct pointer in C using reinterpret_cast. The casted pointer in C is passed to member functions of that object and is used to call the member function of the instance. To delete the object, the pointer is passed to the _destroy function and delete is used to call the deconstructor. For example, for the calss Rectangle below stored in Rectangle.h:\nclass Rectangle{ private: int length; int width; public: Rectangle(int l, int w): length(l), width(w){}; int area(){ return length*width;}; perimeter() { return 2*(lendth+width);}; ~Rectangle(){}; } Two files cwrapper.h and cwrapper.cpp are created to map the Rectangle class to C:\n#ifdef __cplusplus extern \"C\"{ #endif /* Wrapper struct to hold a pointer to Rectangle object in C */ struct WRectangle; typedef struct WRectangle WRectangle; /* Wrapper for the constructor */ WRectangle* Rectangle_create(int l, int w); /* Wrapper for destructor */ void Rectangle_destroy(WRectangle* self); /* Wrapper for method area */ int Rectangle_area(WRectangle* self); /* Wrapper for method perimeter */ int Rectangle_perimeter(WRectangle* self); #ifdef __cplusplus } #endif #include \"Rectangle.h\" #include \"cwrapper.h\" #ifdef __cplusplus extern \"C\"{ #endif WRectangle* Rectangle_create(int l, int w){ //calling the constructor and casting the pointer to WRectangle return reinterpret_cast( new Rectangle(l,w) ); } void Rectangle_destroy(WRectangle* self){ //calling the destructor delete reinterpret_cast(self); } int Rectangle_area(WRectangle* self){ return reinterpret_cast(self)-\u003earea(); } int Rectangle_perimeter(WRectangle* self){ return reinterpret_cast(self)-\u003eperimeter(); } #ifdef __cplusplus } #endif The wrapper functions can be used in C source code to interact with the C++ objects. I manually created two files cwrapper.h and cwrapper.cpp for uThreads library which make the library available in C. These files were maintainable when the library was small and there were not many classes and functions to map. However, as the library grew it became harder and harder to maintain the cwrapper functions for all the classes. Thus, I started exploring other options to generate such interface automatically, where the C++ source code is parsed and analysed and various information is extracted automatically, or to word it better I needed a compiler frontend!\nClang libtooling supports writing standalone tools based on Clang. To generate the C interface, I use Clang AST Matcher to find public methods of specific classes and generate the C functions based on that. To get familiar with Clang AST you can refer to this articls.\nFor this tool to work, you need LLVM and Clang installed on your system. You can either build them from source, which will take a long time to finish, or you can install precompiled packages for your operating system. I am using Calng version 4.0.0 and LLVM version 4.0.0, but I tested the code with Clang and LLVM v3.8 and it works fine. To install Clang and LLVM under ubuntu issue sudo apt-get install llvm clang.\nI am going to explain how I used Clang libtooling to generate the cwrapper files for uThreads. The finished code can be found here. This is not used to generate the actual cwrapper files under uThreads, as it still needs some improvements before it can be used in production. Before I explain the code, let’s go through some rules and issues for generating the cwrapper functions:\nCwrapper functions should only be generated for static and public member functions of each class. There is no point to map private member functions of classes to C. I am not going to map operator overloading, copy constructor and move constructor functions to C, as uThreads classes do not have any of that uThreads does not have a namespace yet (it will be added in the future), so there should be a way of figuring out the name of the classes under uThreads that I want to map to C. If there was a namespace, I could simply find all the classes under that namespace and use them to achieve the goal. But for now, I am using a list of class names to map to C stored in std::vector. Since function overloading is not supported in C, there should be a way to map overloaded functions to C. For now I use numbering to map the overloaded functions to C. e.g., uThread_create and uThread_create_1 are constructors for uThread class. Template functions are not supported in the current version and will be supported in the future. Here, all the functions only accepts builtin types and references to uThreads objects, thus make it easy to generate the C counterparts. However, if objects from outside libraries or even standard libraries are passed to or returned from the functions, it needs additional effort to make it work. Since those classes should be listed separately and a struct in C should be generated for them and a pointer to them stored in the C code. Let’s also take a look at the generated AST by Clang. If you pass -Xclang -ast-dump to clang, you can see the AST that is generated by clang. So issueing the following command in the root directory of uThreads will print out the AST in a simple text format:\nclang++ -Xclang -ast-dump -fsyntax-only -I./src -std=c++11 include/uThreads.h include/uThreads.h is the file that includes all the header files in uThreads, thus all uThreads classes and functions are present when passing the file to clang. Also, since many stdlib and system files are included the resulting AST is going to be very large, as it covers all the included files as well. Here are AST nodes related to constructor, destructor, and method accept from class Connection in uThreads:\nAST Dump AST node related to constructor is of type CXXConstructorDecl, AST node related to the destructor is of type CXXDestructorDecl, and the accept method is of type CXXMethodDecl. CXXConstructorDecl and CXXDestructorDecl are both childern of class CXXMethodDecl. Hence, by finding all method declarations, i.e. CXXMethodDecl, in AST we meet all the requirments to generate the C interface.\nAST matchers are used to find and match AST nodes and perform a specific task based on the matched node. To understand the idea further, let’s use clang-query which can be used to test AST matchers. For instance to query the uThreads AST, issue the following command:\nclang-query include/uThreads.h -- -I./src -std=c++11 It enters clang-query console and you can issue help to see the available commands. Let’s use the match command to find all the CXXMethodDecl in the AST:\nclang-query\u003e match cxxMethodDecl() As before, since many files are included in the source code, the output is going to be large and includes all the methods, constructors and destructors from uThreads and all other classes included. Here is part of the output for class Connection:\nMatch #6987: ./src/io/Network.h:61:5: note: \"root\" binds here Connection() : ^~~~~~~~~~~~~~ Match #6988: ./src/io/Network.h:72:5: note: \"root\" binds here Connection(int fd) : ^~~~~~~~~~~~~~~~~~~~ Match #6989: ./src/io/Network.h:87:5: note: \"root\" binds here Connection(int domain, int type, int protocol) throw(std::system_error); ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Match #6990: ./src/io/Network.h:89:5: note: \"root\" binds here ~Connection(); ^~~~~~~~~~~~~ Match #6991: ./src/io/Network.h:99:5: note: \"root\" binds here int accept(Connection *conn, struct sockaddr *addr, socklen_t *addrlen); ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ However, for the C interface we are only interested in public methods. So let’s change the query to reflect that:\nclang-query\u003e match cxxMethodDecl(isPublic()) This time only the public methods are printed to the output. Also, since we are only interested in classes defined in uThreads library, I am going to use specific class names to limit the output. For example, to see all the public methods from class Connection issue the following commands:\nclang-query\u003e set output dump clang-query\u003e match cxxMethodDecl(isPublic(), ofClass(hasName(\"Connection\"))) This time I changed the output to show AST dump instead of diagnostics, which results in the following:\nBinding for \"root\": CXXConstructorDecl 0x3712520 \u003c./src/io/Network.h:61:5, line:64:5\u003e line:61:5 Connection 'void (void)' |-CXXCtorInitializer Field 0x3712178 'pd' 'class PollData *' | `-CXXDefaultInitExpr 0x37162d8 'class PollData *' |-CXXCtorInitializer Field 0x37121d0 'fd' 'int' | `-UnaryOperator 0x3716260 'int' prefix '-' | `-IntegerLiteral 0x3716240 'int' 1 |-CompoundStmt 0x37163a8 | `-CXXMemberCallExpr 0x3716380 'void' | `-MemberExpr 0x3716348 '' -\u003einit 0x3712298 | `-CXXThisExpr 0x3716330 'class Connection *' this `-FullComment 0x3940930 |-ParagraphComment 0x3940800 | `-TextComment 0x39407d0 Text=\" \" |-BlockCommandComment 0x3940820 Name=\"brief\" | `-ParagraphComment 0x3940880 | `-TextComment 0x3940850 Text=\" Create a Connection that does not have\" `-ParagraphComment 0x39408f0 |-TextComment 0x39408a0 Text=\" This is useful for accept or socket functions that require\" `-TextComment 0x39408c0 Text=\" a Connection object without fd being set\" Match #2: Binding for \"root\": CXXConstructorDecl 0x37126a0 \u003c./src/io/Network.h:72:5, line:75:5\u003e line:72:5 Connection 'void (int)' |-ParmVarDecl 0x3712618 col:20 used fd 'int' |-CXXCtorInitializer Field 0x3712178 'pd' 'class PollData *' | `-CXXDefaultInitExpr 0x3716460 'class PollData *' |-CXXCtorInitializer Field 0x37121d0 'fd' 'int' | `-ImplicitCastExpr 0x3716420 'int' | `-DeclRefExpr 0x37163c8 'int' lvalue ParmVar 0x3712618 'fd' 'int' |-CompoundStmt 0x3716530 | `-CXXMemberCallExpr 0x3716508 'void' | `-MemberExpr 0x37164d0 '' -\u003einit 0x3712298 | `-CXXThisExpr 0x37164b8 'class Connection *' this `-FullComment 0x3940ba0 |-ParagraphComment 0x39409d0 | `-TextComment 0x39409a0 Text=\" \" |-BlockCommandComment 0x39409f0 Name=\"brief\" | `-ParagraphComment 0x3940a70 | |-TextComment 0x3940a20 Text=\" Create a connection object with the provided fd\" | `-TextComment 0x3940a40 Text=\" \" |-ParamCommandComment 0x3940a90 [in] implicitly Param=\"fd\" ParamIndex=0 | `-ParagraphComment 0x3940af0 \u003c\u003e `-ParagraphComment 0x3940b60 |-TextComment 0x3940b10 Text=\" If the connection is already established by other means, set the\" `-TextComment 0x3940b30 Text=\" fd and add it to the polling structure\" Match #3: Binding for \"root\": CXXConstructorDecl 0x37129b0 \u003c./src/io/Network.h:87:5, col:75\u003e col:5 Connection 'void (int, int, int) throw(std::system_error)' |-ParmVarDecl 0x3712798 col:20 domain 'int' |-ParmVarDecl 0x3712808 col:32 type 'int' |-ParmVarDecl 0x3712878 col:42 protocol 'int' `-FullComment 0x3940ec0 |-ParagraphComment 0x3940c40 | `-TextComment 0x3940c10 Text=\" \" |-BlockCommandComment 0x3940c60 Name=\"brief\" | `-ParagraphComment 0x3940ce0 | |-TextComment 0x3940c90 Text=\" Same as socket syscall adds | SOCK_NONBLOCK to type\" | `-TextComment 0x3940cb0 Text=\" \" |-BlockCommandComment 0x3940d00 Name=\"return\" | `-ParagraphComment 0x3940d60 | `-TextComment 0x3940d30 Text=\" same as socket syscall\" |-ParagraphComment 0x3940e20 | |-TextComment 0x3940d80 Text=\" Throws a std::system_error exception. Do not call from C code.\" | |-TextComment 0x3940da0 Text=\" The unerlying socket is always nonbelocking. This is achieved\" | |-TextComment 0x3940dc0 Text=\" by adding a (| SOCK_NONBLOCK) to type, thus requires\" | `-TextComment 0x3940de0 Text=\" linux kernels \u003e 2.6.27\" `-ParagraphComment 0x3940e70 `-TextComment 0x3940e40 Text=\" \" Match #4: Binding for \"root\": CXXDestructorDecl 0x3712ad0 \u003c./src/io/Network.h:89:5, col:17\u003e col:5 ~Connection 'void (void)' noexcept-unevaluated 0x3712ad0 We can use the final version of the matcher to find the public methods of interest and generate C source code based on that. We start by creating an option category which is applied to all command-line options. Also you can define new options for the command line tool using option tables, so arguments can be passed to your program. I am not going to use that feature in the current implementation, but included “-o” option just to show how it’s done:\n/** Options **/ static cl::OptionCategory CPP2CCategory(\"CPP2C options\"); static std::unique_ptr Options(createDriverOptTable()); static cl::opt OutputFilename(\"o\", cl::desc(Options-\u003egetOptionHelpText((options::OPT_o)))); I also create a struct with custom string streams which is used to generate the final C .h and .c files, a vector of the name of the classes from uThreads to be explored and a map of function names to an integer, which is used to keep track of functions and detect overleaded functions.\n/** Classes to be mapped to C **/ struct OutputStreams{ string headerString; string bodyString; llvm::raw_string_ostream HeaderOS; llvm::raw_string_ostream BodyOS; OutputStreams() : headerString(\"\"), bodyString(\"\"), HeaderOS(headerString), BodyOS(bodyString){}; }; vector ClassList = {\"uThread\", \"kThread\", \"Cluster\", \"Connection\", \"Mutex\", \"OwnerLock\", \"ConditionVariable\", \"Semaphore\", \"uThreadPool\"}; map funcList; Next, we write the main function:\nint main(int argc, const char **argv) { // parse the command-line args passed to your code CommonOptionsParser op(argc, argv, CPP2CCategory); // create a new Clang Tool instance (a LibTooling environment) ClangTool Tool(op.getCompilations(), op.getSourcePathList()); // run the Clang Tool, creating a new FrontendAction return Tool.run(newFrontendActionFactory().get()); } Whithin the main function, we pass the OptionCategory to the CommonOptionsParser along with argc and argv to parse the arguments passed to the code. Next, We create a ClangTool instance and pass the Compilation and source path lists to it. Finally, the ClangTool needs a new FrontendAction for each translation unit we run on. Thus, it takes a FrontendActionFactory as parameter. To create a FrontendActionFactory from a given FrontendAction type, we call newFrontendActionFactory(). MyFrontendAction is a ASTFrontendAction which is used for AST consumer-based frontend actions, and since we are going to rely on AST matchers we use the ASTFrontendAction.\n// For each source file provided to the tool, a new FrontendAction is created. class MyFrontendAction: public ASTFrontendAction { public: MyFrontendAction() { OS.HeaderOS \u003c\u003c \"#ifndef UTHREADS_CWRAPPER_H\\n\" \"#define UTHREADS_CWRAPPER_H_\\n\" \"#include \\n\" \"#include \\n\" \"#include \\n\" \"#include \\n\\n\" \"#ifdef __cplusplus\\n\" \"extern \\\"C\\\"{\\n\" \"#endif\\n\" \"#include \\n\"; OS.BodyOS \u003c\u003c \"#include \\\"generic/basics.h\\\"\\n\" \"#include \\\"cwrapper.h\\\"\\n\" \"#include \\\"runtime/uThread.h\\\"\\n\" \"#include \\\"runtime/uThreadPool.h\\\"\\n\" \"#include \\\"runtime/kThread.h\\\"\\n\" \"#include \\\"io/Network.h\\\"\\n\" \"#ifdef __cplusplus\\n\" \"extern \\\"C\\\"{\\n\" \"#endif\\n\"; } void EndSourceFileAction() override { StringRef headerFile(\"cwrapper.h\"); StringRef bodyFile(\"cwrapper.cpp\"); // Open the output file std::error_code EC; llvm::raw_fd_ostream HOS(headerFile, EC, llvm::sys::fs::F_None); if (EC) { llvm::errs() \u003c\u003c \"while opening '\" \u003c\u003c headerFile\u003c\u003c \"': \" \u003c\u003c EC.message() \u003c\u003c '\\n'; exit(1); } llvm::raw_fd_ostream BOS(bodyFile, EC, llvm::sys::fs::F_None); if (EC) { llvm::errs() \u003c\u003c \"while opening '\" \u003c\u003c bodyFile\u003c\u003c \"': \" \u003c\u003c EC.message() \u003c\u003c '\\n'; exit(1); } OS.HeaderOS \u003c\u003c \"#ifdef __cplusplus\\n\" \"}\\n\" \"#endif\\n\" \"#endif /* UTHREADS_CWRAPPER_H_ */\\n\"; OS.BodyOS\u003c\u003c \"#ifdef __cplusplus\\n\" \"}\\n\" \"#endif\\n\"; OS.HeaderOS.flush(); OS.BodyOS.flush(); HOS\u003c\u003c OS.headerString \u003c\u003c \"\\n\"; BOS\u003c\u003c OS.bodyString \u003c\u003c \"\\n\"; } std::unique_ptr CreateASTConsumer(CompilerInstance \u0026CI, StringRef file) override { return llvm::make_unique(OS); } private: OutputStreams OS; }; MyFrontendAction includes an instance of OutputStreams that has two string streams, one for the header file and the other one for the .cpp file. Both streams are intialized with the required include statements and #ifdef statements to be placed at the beginning of the file. The EndSourceFileAction is a callback at the end of processing a single input, and is used to append required strings to the end of the streams and save the streams to cwrapper.h and cwrapper.cpp files. Finally, CreateASTConsumer is called to create the AST consumer object for this action. Here an instance of MyASTConsumer is created and returned, we also pass the OutputStreams instance by reference, so later it can be passed to handlers. AST consumer, in our case, is responsible for registering matchers and run them over the AST. Here, the list of classes is used along with the cxxMethodDecl matcher we came up with earlier to match the methods of interest.\n// Implementation of the ASTConsumer interface for reading an AST produced // by the Clang parser. It registers a couple of matchers and runs them on // the AST. class MyASTConsumer: public ASTConsumer { public: MyASTConsumer(OutputStreams\u0026 os) : OS(os), HandlerForClassMatcher(os){ // Add a simple matcher for finding 'if' statements. for(string\u0026 className : ClassList){ OS.HeaderOS \u003c\u003c \"struct W\"\u003c\u003c className \u003c\u003c \"; \\n\" \"typedef struct W\"\u003c\u003c className \u003c\u003c \" W\"\u003c\u003c className \u003c\u003c \";\\n\"; //oss.push_back(std::move(os)) DeclarationMatcher classMatcher = cxxMethodDecl(isPublic(), ofClass(hasName(className))).bind(\"publicMethodDecl\"); Matcher.addMatcher(classMatcher, \u0026HandlerForClassMatcher); } } void HandleTranslationUnit(ASTContext \u0026Context) override { // Run the matchers when we have the whole TU parsed. Matcher.matchAST(Context); } private: OutputStreams\u0026 OS; classMatchHandler HandlerForClassMatcher; MatchFinder Matcher; }; MyASTConsumer has an instance of a classMatchHandler and a MatchFinder. MatchFinder is used to register matchers and handlers and to apply the matchers to AST Context and call the related handlers when a match is found. In the constructor, we add all the matchers using addMatcher, and under the HandleTranslationUnit we call matchAST to perform the matches and do the callbacks. We also bind the match to a string (publicMethodDecl), which is used later to differentiate among matchers. Also, notice that for each class a struct is generated with name WclassName along with a typedef with the same name. As explained eariler, this struct is used to hold a pointer to the instance of the class in C.\nClass classMatchHandler is a child of MatchFinder::MatchCallBack class, and is used to perform the required task after a match is found. We also override member function run, that accepts a MatchResult and is called upon finding a match. The first step is to check whether the matched node with the provided string publicMethodDecl is of type cxxMethodDecl.\nif (const CXXMethodDecl *cmd = Result.Nodes.getNodeAs(\"publicMethodDecl\")){ string methodName = \"\"; string className = cmd-\u003egetParent()-\u003egetDeclName().getAsString(); string returnType = \"\"; string returnCast = \"\"; bool shouldReturn, isPointer; string self = \"W\" + className + \"* self\"; string separator = \", \"; string bodyEnd = \"\"; std::stringstream functionBody; If so, we create a few of strings variables in order to generate the final C method. className captures the name of the parent class of the method, i.e. the name used to find the method in the matcher, by getting the declaration name of the parent class as string. To map member functions to C, there is a need to send the pointer to the object as the first argument, so the string self contains the string that represents the pointer to the struct in C that is named as self. The rest of the variables are explained later.\nAs explained eariler, operator overloading is ignored and not mapped to C, thus:\n//ignore operator overloadings if(cmd-\u003eisOverloadedOperator()) return; Next, we check whether the matched method is a constructor:\n//constructor if (const CXXConstructorDecl* ccd = dyn_cast(cmd)) { if(ccd-\u003eisCopyConstructor() || ccd-\u003eisMoveConstructor()) return; methodName = \"_create\"; returnType = \"W\" + className + \"*\"; self = \"\"; separator = \"\"; functionBody \u003c\u003c \"return reinterpret_cast\u003c\"\u003c\u003c returnType \u003c\u003c \"\u003e( new \" \u003c\u003c className \u003c\u003c \"(\"; bodyEnd += \"))\"; If cmd can be dynamically casted to CXXConstructorDecl, it means the method is a constructor. If the constructor is a copy constructor or move constructor we are not going to map it to C as explained above. The final method name should be className_create, so we set the methodName to be _create and later concatenate it to the calss name. Also, since the constructor creates an instance of the object and return a pointer to the created object, the return type should be the same as the struct type that holds the pointer to the object in C. self string will be empty, since there is no instance of the object yet to be passed to the constructor. separator is used to separate function arguments in the string, and since there is no self, the next argument do not need a comma before it. functionBody is a string stream that holds the information related to the function definition. For the constructor, we know that it returns the casted pointer to the object created by new, so the related string is generated accordingly. bodyEnd holds the string to complete the function definition, and since there are two open parentheses, they should be closed after arguments are placed in between the parentheses.\nNext, we check wether the method is a destructor:\n}else if (isa(cmd)) { methodName = \"_destroy\"; returnType = \"void\"; functionBody \u003c\u003c \" delete reinterpret_cast\u003c\"\u003c","wordCount":"4499","inLanguage":"en","datePublished":"2016-12-06T10:40:49-05:00","dateModified":"2016-12-06T10:40:49-05:00","author":{"@type":"Person","name":"Saman Barghi"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://samanbarghi.com/post/using-clang-libtooling-to-generate-c-interface-from-c++-source-code/"},"publisher":{"@type":"Organization","name":"Saman Barghi","logo":{"@type":"ImageObject","url":"http://samanbarghi.com/images/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://samanbarghi.com/ accesskey=h title="Home (Alt + H)"><img src=http://samanbarghi.com/images/favicon/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://samanbarghi.com/about/ title=about><span>about</span></a></li><li><a href=http://samanbarghi.com/projects/ title=projects><span>projects</span></a></li><li><a href=http://samanbarghi.com/categories/ title=categories><span>categories</span></a></li><li><a href=http://samanbarghi.com/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://samanbarghi.com/>Home</a>&nbsp;»&nbsp;<a href=http://samanbarghi.com/post/>Posts</a></div><h1 class=post-title>Generate C interface from C++ source code using Clang libtooling</h1><div class=post-description>Using Clang libtooling for LLVM to generate C interface from C++ source code.</div><div class=post-meta><span title='2016-12-06 10:40:49 -0500 -0500'>December 6, 2016</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;4499 words&nbsp;·&nbsp;Saman Barghi&nbsp;|&nbsp;<a href=https://github.com/samanbarghi/samanbarghi-hugo/tree/master/content/post/using-clang-libtooling-to-generate-C-interface-from-C++-source-code.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>I developed a <a href=https://github.com/samanbarghi/uThreads>concurrent user-thread library</a> using C++, and was looking for a way to provide a C interface and make the functionality available in C. In order to achieve this goal, I started writting a C wrapper interface manually where each public method of a class is mapped to a function in C with the class name followed by the function name. Also, constructors are mapped to class name followed by <em>_create</em> and destructors are mapped to the class name followed by <em>_destory</em>. To create an object, memory is allocated using <em>new</em> in C++ and the pointer is casted to a struct pointer in C using <em>reinterpret_cast</em>. The casted pointer in C is passed to member functions of that object and is used to call the member function of the instance. To delete the object, the pointer is passed to the <em>_destroy</em> function and <em>delete</em> is used to call the deconstructor. For example, for the calss Rectangle below stored in <code>Rectangle.h</code>:</p><pre tabindex=0><code>class Rectangle{
  private:
    int length;
    int width;
  public:
  Rectangle(int l, int w): length(l), width(w){};
  int area(){ return length*width;};
  perimeter() { return 2*(lendth+width);};
  ~Rectangle(){};
}
</code></pre><p>Two files <code>cwrapper.h</code> and <code>cwrapper.cpp</code> are created to map the Rectangle class to C:</p><pre tabindex=0><code>#ifdef __cplusplus
extern &#34;C&#34;{
#endif

/* Wrapper struct to hold a pointer to
   Rectangle object in C  */
struct      WRectangle;             
typedef     struct WRectangle WRectangle;

/* Wrapper for the constructor */
WRectangle*   Rectangle_create(int l, int w);     
/* Wrapper for destructor */
void  Rectangle_destroy(WRectangle* self);
/* Wrapper for method area */
int Rectangle_area(WRectangle* self);
/* Wrapper for method perimeter */
int Rectangle_perimeter(WRectangle* self);
#ifdef __cplusplus
}
#endif
</code></pre><pre tabindex=0><code>#include &#34;Rectangle.h&#34;
#include &#34;cwrapper.h&#34;

#ifdef __cplusplus
extern &#34;C&#34;{
#endif

WRectangle*   Rectangle_create(int l, int w){
  //calling the constructor and casting the pointer to WRectangle
  return reinterpret_cast&lt;WRectangle*&gt;( new Rectangle(l,w) );
}
void  Rectangle_destroy(WRectangle* self){
  //calling the destructor
  delete reinterpret_cast&lt;Rectangle*&gt;(self);
}
int Rectangle_area(WRectangle* self){
    return reinterpret_cast&lt;Rectangle*&gt;(self)-&gt;area();
}
int Rectangle_perimeter(WRectangle* self){
    return reinterpret_cast&lt;Rectangle*&gt;(self)-&gt;perimeter();
}
#ifdef __cplusplus
}
#endif
</code></pre><p>The wrapper functions can be used in C source code to interact with the C++ objects. I manually created two files <a href=https://github.com/samanbarghi/uThreads/blob/v0.3.0/src/cwrapper.h>cwrapper.h</a> and <a href=https://github.com/samanbarghi/uThreads/blob/v0.3.0/src/cwrapper.cpp>cwrapper.cpp</a> for uThreads library which make the library available in C. These files were maintainable when the library was small and there were not many classes and functions to map. However, as the library grew it became harder and harder to maintain the cwrapper functions for all the classes. Thus, I started exploring other options to generate such interface automatically, where the C++ source code is parsed and analysed and various information is extracted automatically, or to word it better I needed a compiler frontend!</p><p><a href=http://clang.llvm.org/docs/LibTooling.html>Clang libtooling</a> supports writing standalone tools based on Clang. To generate the C interface, I use <a href=http://clang.llvm.org/docs/LibASTMatchersReference.html>Clang AST Matcher</a> to find public methods of specific classes and generate the C functions based on that. To get familiar with Clang AST you can refer to <a href=http://clang.llvm.org/docs/IntroductionToTheClangAST.html>this articls</a>.</p><p>For this tool to work, you need LLVM and Clang installed on your system. You can either <a href=http://clang.llvm.org/get_started.html>build them from source</a>, which will take a long time to finish, or you can install precompiled packages for your operating system. I am using Calng version 4.0.0 and LLVM version 4.0.0, but I tested the code with Clang and LLVM v3.8 and it works fine. To install Clang and LLVM under ubuntu issue <code>sudo apt-get install llvm clang</code>.</p><p>I am going to explain how I used Clang libtooling to generate the cwrapper files for uThreads. The finished code can be found <a href=https://github.com/samanbarghi/CPP2C>here</a>. This is not used to generate the actual cwrapper files under uThreads, as it still needs some improvements before it can be used in production. Before I explain the code, let&rsquo;s go through some rules and issues for generating the cwrapper functions:</p><ul><li>Cwrapper functions should only be generated for static and public member functions of each class. There is no point to map private member functions of classes to C.</li><li>I am not going to map operator overloading, copy constructor and move constructor functions to C, as uThreads classes do not have any of that</li><li>uThreads does not have a namespace yet (it will be added in the future), so there should be a way of figuring out the name of the classes under uThreads that I want to map to C. If there was a namespace, I could simply find all the classes under that namespace and use them to achieve the goal. But for now, I am using a list of class names to map to C stored in <code>std::vector</code>.</li><li>Since function overloading is not supported in C, there should be a way to map overloaded functions to C. For now I use numbering to map the overloaded functions to C. e.g., uThread_create and uThread_create_1 are constructors for uThread class.</li><li>Template functions are not supported in the current version and will be supported in the future.</li><li>Here, all the functions only accepts builtin types and references to uThreads objects, thus make it easy to generate the C counterparts. However, if objects from outside libraries or even standard libraries are passed to or returned from the functions, it needs additional effort to make it work. Since those classes should be listed separately and a struct in C should be generated for them and a pointer to them stored in the C code.</li></ul><p>Let&rsquo;s also take a look at the generated AST by Clang. If you pass <code>-Xclang -ast-dump</code> to clang, you can see the AST that is generated by clang. So issueing the following command in the root directory of uThreads will print out the AST in a simple text format:</p><pre tabindex=0><code>clang++ -Xclang -ast-dump -fsyntax-only -I./src -std=c++11 include/uThreads.h
</code></pre><p><code>include/uThreads.h</code> is the file that includes all the header files in uThreads, thus all uThreads classes and functions are present when passing the file to clang. Also, since many stdlib and system files are included the resulting AST is going to be very large, as it covers all the included files as well. Here are AST nodes related to constructor, destructor, and method <code>accept</code> from class Connection in uThreads:</p><p><a href=/images/2016-12-06/ast-dump.png><figure><img loading=lazy src=/images/2016-12-06/ast-dump.png><figcaption>AST Dump</figcaption></figure></a></p><p>AST node related to constructor is of type <code>CXXConstructorDecl</code>, AST node related to the destructor is of type <code>CXXDestructorDecl</code>, and the accept method is of type <code>CXXMethodDecl</code>. <a href=http://clang.llvm.org/doxygen/classclang_1_1CXXConstructorDecl.html>CXXConstructorDecl</a> and <a href=http://clang.llvm.org/doxygen/classclang_1_1CXXDestructorDecl.html>CXXDestructorDecl</a> are both childern of class <code>CXXMethodDecl</code>. Hence, by finding all method declarations, i.e. <code>CXXMethodDecl</code>, in AST we meet all the requirments to generate the C interface.</p><p><a href=http://clang.llvm.org/docs/LibASTMatchersReference.html>AST matchers</a> are used to find and match AST nodes and perform a specific task based on the matched node. To understand the idea further, let&rsquo;s use <code>clang-query</code> which can be used to test AST matchers. For instance to query the uThreads AST, issue the following command:</p><pre tabindex=0><code>clang-query include/uThreads.h -- -I./src -std=c++11
</code></pre><p>It enters <code>clang-query</code> console and you can issue <code>help</code> to see the available commands. Let&rsquo;s use the <code>match</code> command to find all the <code>CXXMethodDecl</code> in the AST:</p><pre tabindex=0><code>clang-query&gt; match cxxMethodDecl()
</code></pre><p>As before, since many files are included in the source code, the output is going to be large and includes all the methods, constructors and destructors from uThreads and all other classes included. Here is part of the output for class <code>Connection</code>:</p><pre tabindex=0><code>Match #6987:

./src/io/Network.h:61:5: note: &#34;root&#34; binds here
    Connection() :
    ^~~~~~~~~~~~~~

Match #6988:

./src/io/Network.h:72:5: note: &#34;root&#34; binds here
    Connection(int fd) :
    ^~~~~~~~~~~~~~~~~~~~

Match #6989:

./src/io/Network.h:87:5: note: &#34;root&#34; binds here
    Connection(int domain, int type, int protocol) throw(std::system_error);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Match #6990:

./src/io/Network.h:89:5: note: &#34;root&#34; binds here
    ~Connection();
    ^~~~~~~~~~~~~

Match #6991:

./src/io/Network.h:99:5: note: &#34;root&#34; binds here
    int accept(Connection *conn, struct sockaddr *addr, socklen_t *addrlen);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre><p>However, for the C interface we are only interested in public methods. So let&rsquo;s change the query to reflect that:</p><pre tabindex=0><code>clang-query&gt; match cxxMethodDecl(isPublic())
</code></pre><p>This time only the public methods are printed to the output. Also, since we are only interested in classes defined in uThreads library, I am going to use specific class names to limit the output. For example, to see all the public methods from class <code>Connection</code> issue the following commands:</p><pre tabindex=0><code>clang-query&gt; set output dump
clang-query&gt; match cxxMethodDecl(isPublic(), ofClass(hasName(&#34;Connection&#34;)))
</code></pre><p>This time I changed the output to show AST dump instead of diagnostics, which results in the following:</p><pre tabindex=0><code>Binding for &#34;root&#34;:
CXXConstructorDecl 0x3712520 &lt;./src/io/Network.h:61:5, line:64:5&gt; line:61:5 Connection &#39;void (void)&#39;
|-CXXCtorInitializer Field 0x3712178 &#39;pd&#39; &#39;class PollData *&#39;
| `-CXXDefaultInitExpr 0x37162d8 &lt;col:5&gt; &#39;class PollData *&#39;
|-CXXCtorInitializer Field 0x37121d0 &#39;fd&#39; &#39;int&#39;
| `-UnaryOperator 0x3716260 &lt;line:62:16, col:17&gt; &#39;int&#39; prefix &#39;-&#39;
|   `-IntegerLiteral 0x3716240 &lt;col:17&gt; &#39;int&#39; 1
|-CompoundStmt 0x37163a8 &lt;col:19, line:64:5&gt;
| `-CXXMemberCallExpr 0x3716380 &lt;line:63:9, col:14&gt; &#39;void&#39;
|   `-MemberExpr 0x3716348 &lt;col:9&gt; &#39;&lt;bound member function type&gt;&#39; -&gt;init 0x3712298
|     `-CXXThisExpr 0x3716330 &lt;col:9&gt; &#39;class Connection *&#39; this
`-FullComment 0x3940930 &lt;line:56:7, line:59:47&gt;
  |-ParagraphComment 0x3940800 &lt;line:56:7&gt;
  | `-TextComment 0x39407d0 &lt;col:7&gt; Text=&#34; &#34;
  |-BlockCommandComment 0x3940820 &lt;col:8, col:52&gt; Name=&#34;brief&#34;
  | `-ParagraphComment 0x3940880 &lt;col:14, col:52&gt;
  |   `-TextComment 0x3940850 &lt;col:14, col:52&gt; Text=&#34; Create a Connection that does not have&#34;
  `-ParagraphComment 0x39408f0 &lt;line:58:7, line:59:47&gt;
    |-TextComment 0x39408a0 &lt;line:58:7, col:65&gt; Text=&#34; This is useful for accept or socket functions that require&#34;
    `-TextComment 0x39408c0 &lt;line:59:7, col:47&gt; Text=&#34; a Connection object without fd being set&#34;


Match #2:

Binding for &#34;root&#34;:
CXXConstructorDecl 0x37126a0 &lt;./src/io/Network.h:72:5, line:75:5&gt; line:72:5 Connection &#39;void (int)&#39;
|-ParmVarDecl 0x3712618 &lt;col:16, col:20&gt; col:20 used fd &#39;int&#39;
|-CXXCtorInitializer Field 0x3712178 &#39;pd&#39; &#39;class PollData *&#39;
| `-CXXDefaultInitExpr 0x3716460 &lt;col:5&gt; &#39;class PollData *&#39;
|-CXXCtorInitializer Field 0x37121d0 &#39;fd&#39; &#39;int&#39;
| `-ImplicitCastExpr 0x3716420 &lt;line:73:16&gt; &#39;int&#39; &lt;LValueToRValue&gt;
|   `-DeclRefExpr 0x37163c8 &lt;col:16&gt; &#39;int&#39; lvalue ParmVar 0x3712618 &#39;fd&#39; &#39;int&#39;
|-CompoundStmt 0x3716530 &lt;col:20, line:75:5&gt;
| `-CXXMemberCallExpr 0x3716508 &lt;line:74:9, col:14&gt; &#39;void&#39;
|   `-MemberExpr 0x37164d0 &lt;col:9&gt; &#39;&lt;bound member function type&gt;&#39; -&gt;init 0x3712298
|     `-CXXThisExpr 0x37164b8 &lt;col:9&gt; &#39;class Connection *&#39; this
`-FullComment 0x3940ba0 &lt;line:66:7, line:70:45&gt;
  |-ParagraphComment 0x39409d0 &lt;line:66:7&gt;
  | `-TextComment 0x39409a0 &lt;col:7&gt; Text=&#34; &#34;
  |-BlockCommandComment 0x39409f0 &lt;col:8, line:67:7&gt; Name=&#34;brief&#34;
  | `-ParagraphComment 0x3940a70 &lt;line:66:14, line:67:7&gt;
  |   |-TextComment 0x3940a20 &lt;line:66:14, col:61&gt; Text=&#34; Create a connection object with the provided fd&#34;
  |   `-TextComment 0x3940a40 &lt;line:67:7&gt; Text=&#34; &#34;
  |-ParamCommandComment 0x3940a90 &lt;col:8, col:16&gt; [in] implicitly Param=&#34;fd&#34; ParamIndex=0
  | `-ParagraphComment 0x3940af0 &lt;&lt;invalid sloc&gt;&gt;
  `-ParagraphComment 0x3940b60 &lt;line:69:7, line:70:45&gt;
    |-TextComment 0x3940b10 &lt;line:69:7, col:71&gt; Text=&#34; If the connection is already established by other means, set the&#34;
    `-TextComment 0x3940b30 &lt;line:70:7, col:45&gt; Text=&#34; fd and add it to the polling structure&#34;


Match #3:

Binding for &#34;root&#34;:
CXXConstructorDecl 0x37129b0 &lt;./src/io/Network.h:87:5, col:75&gt; col:5 Connection &#39;void (int, int, int) throw(std::system_error)&#39;
|-ParmVarDecl 0x3712798 &lt;col:16, col:20&gt; col:20 domain &#39;int&#39;
|-ParmVarDecl 0x3712808 &lt;col:28, col:32&gt; col:32 type &#39;int&#39;
|-ParmVarDecl 0x3712878 &lt;col:38, col:42&gt; col:42 protocol &#39;int&#39;
`-FullComment 0x3940ec0 &lt;line:78:7, line:86:5&gt;
  |-ParagraphComment 0x3940c40 &lt;line:78:7&gt;
  | `-TextComment 0x3940c10 &lt;col:7&gt; Text=&#34; &#34;
  |-BlockCommandComment 0x3940c60 &lt;col:8, line:79:7&gt; Name=&#34;brief&#34;
  | `-ParagraphComment 0x3940ce0 &lt;line:78:14, line:79:7&gt;
  |   |-TextComment 0x3940c90 &lt;line:78:14, col:65&gt; Text=&#34; Same as socket syscall adds | SOCK_NONBLOCK to type&#34;
  |   `-TextComment 0x3940cb0 &lt;line:79:7&gt; Text=&#34; &#34;
  |-BlockCommandComment 0x3940d00 &lt;col:8, col:37&gt; Name=&#34;return&#34;
  | `-ParagraphComment 0x3940d60 &lt;col:15, col:37&gt;
  |   `-TextComment 0x3940d30 &lt;col:15, col:37&gt; Text=&#34; same as socket syscall&#34;
  |-ParagraphComment 0x3940e20 &lt;line:81:7, line:84:29&gt;
  | |-TextComment 0x3940d80 &lt;line:81:7, col:69&gt; Text=&#34; Throws a std::system_error exception. Do not call from C code.&#34;
  | |-TextComment 0x3940da0 &lt;line:82:7, col:68&gt; Text=&#34; The unerlying socket is always nonbelocking. This is achieved&#34;
  | |-TextComment 0x3940dc0 &lt;line:83:7, col:60&gt; Text=&#34; by adding a  (| SOCK_NONBLOCK) to type, thus requires&#34;
  | `-TextComment 0x3940de0 &lt;line:84:7, col:29&gt; Text=&#34; linux kernels &gt; 2.6.27&#34;
  `-ParagraphComment 0x3940e70 &lt;line:86:1, col:5&gt;
    `-TextComment 0x3940e40 &lt;col:1, col:5&gt; Text=&#34;     &#34;


Match #4:

Binding for &#34;root&#34;:
CXXDestructorDecl 0x3712ad0 &lt;./src/io/Network.h:89:5, col:17&gt; col:5 ~Connection &#39;void (void)&#39; noexcept-unevaluated 0x3712ad0
</code></pre><p>We can use the final version of the matcher to find the public methods of interest and generate C source code based on that. We start by creating an option category which is applied to all command-line options. Also you can define new options for the command line tool using option tables, so arguments can be passed to your program. I am not going to use that feature in the current implementation, but included &ldquo;-o&rdquo; option just to show how it&rsquo;s done:</p><pre tabindex=0><code>/** Options **/
static cl::OptionCategory CPP2CCategory(&#34;CPP2C options&#34;);
static std::unique_ptr&lt;opt::OptTable&gt; Options(createDriverOptTable());
static cl::opt&lt;std::string&gt; OutputFilename(&#34;o&#34;, cl::desc(Options-&gt;getOptionHelpText((options::OPT_o))));
</code></pre><p>I also create a struct with custom string streams which is used to generate the final C <code>.h</code> and <code>.c</code> files, a vector of the name of the classes from uThreads to be explored and a map of function names to an integer, which is used to keep track of functions and detect overleaded functions.</p><pre tabindex=0><code>/** Classes to be mapped to C **/
struct OutputStreams{
	string headerString;
	string bodyString;

	llvm::raw_string_ostream HeaderOS;
	llvm::raw_string_ostream BodyOS;

	OutputStreams() : headerString(&#34;&#34;), bodyString(&#34;&#34;), HeaderOS(headerString), BodyOS(bodyString){};
};


vector&lt;string&gt; ClassList = {&#34;uThread&#34;, &#34;kThread&#34;, &#34;Cluster&#34;, &#34;Connection&#34;, &#34;Mutex&#34;, &#34;OwnerLock&#34;, &#34;ConditionVariable&#34;, &#34;Semaphore&#34;, &#34;uThreadPool&#34;};

map&lt;string, int&gt; funcList;
</code></pre><p>Next, we write the main function:</p><pre tabindex=0><code>int main(int argc, const char **argv) {
	// parse the command-line args passed to your code
	CommonOptionsParser op(argc, argv, CPP2CCategory);
	// create a new Clang Tool instance (a LibTooling environment)
	ClangTool Tool(op.getCompilations(), op.getSourcePathList());


	// run the Clang Tool, creating a new FrontendAction
	return Tool.run(newFrontendActionFactory&lt;MyFrontendAction&gt;().get());
}
</code></pre><p>Whithin the main function, we pass the OptionCategory to the <code>CommonOptionsParser</code> along with argc and argv to parse the arguments passed to the code. Next, We create a <code>ClangTool</code> instance and pass the Compilation and source path lists to it. Finally, the ClangTool needs a new FrontendAction for each translation unit we run
on. Thus, it takes a FrontendActionFactory as parameter. To create a <code>FrontendActionFactory</code> from a given FrontendAction type, we call <code>newFrontendActionFactory&lt;MyFrontendAction>()</code>. <code>MyFrontendAction</code> is a <code>ASTFrontendAction</code> which is used for AST consumer-based frontend actions, and since we are going to rely on AST matchers we use the <code>ASTFrontendAction</code>.</p><pre tabindex=0><code>// For each source file provided to the tool, a new FrontendAction is created.
 class MyFrontendAction: public ASTFrontendAction {
public:
	MyFrontendAction() {
		OS.HeaderOS &lt;&lt; 	&#34;#ifndef UTHREADS_CWRAPPER_H\n&#34;
						&#34;#define UTHREADS_CWRAPPER_H_\n&#34;
						&#34;#include &lt;pthread.h&gt;\n&#34;
						&#34;#include &lt;sys/types.h&gt;\n&#34;
						&#34;#include &lt;sys/socket.h&gt;\n&#34;
						&#34;#include &lt;inttypes.h&gt;\n\n&#34;

						&#34;#ifdef __cplusplus\n&#34;
						&#34;extern \&#34;C\&#34;{\n&#34;
						&#34;#endif\n&#34;
						&#34;#include &lt;stdbool.h&gt;\n&#34;;
		OS.BodyOS &lt;&lt; &#34;#include \&#34;generic/basics.h\&#34;\n&#34;
					&#34;#include \&#34;cwrapper.h\&#34;\n&#34;
					&#34;#include \&#34;runtime/uThread.h\&#34;\n&#34;
					&#34;#include \&#34;runtime/uThreadPool.h\&#34;\n&#34;
					&#34;#include \&#34;runtime/kThread.h\&#34;\n&#34;
					&#34;#include \&#34;io/Network.h\&#34;\n&#34;
						&#34;#ifdef __cplusplus\n&#34;
						&#34;extern \&#34;C\&#34;{\n&#34;
						&#34;#endif\n&#34;;

	}

	void EndSourceFileAction() override {

		StringRef headerFile(&#34;cwrapper.h&#34;);
		StringRef bodyFile(&#34;cwrapper.cpp&#34;);

        // Open the output file
        std::error_code EC;
        llvm::raw_fd_ostream HOS(headerFile, EC, llvm::sys::fs::F_None);
        if (EC) {
            llvm::errs() &lt;&lt; &#34;while opening &#39;&#34; &lt;&lt; headerFile&lt;&lt; &#34;&#39;: &#34;
            &lt;&lt; EC.message() &lt;&lt; &#39;\n&#39;;
            exit(1);
        }
        llvm::raw_fd_ostream BOS(bodyFile, EC, llvm::sys::fs::F_None);
        if (EC) {
            llvm::errs() &lt;&lt; &#34;while opening &#39;&#34; &lt;&lt; bodyFile&lt;&lt; &#34;&#39;: &#34;
            &lt;&lt; EC.message() &lt;&lt; &#39;\n&#39;;
            exit(1);
        }


		OS.HeaderOS &lt;&lt; &#34;#ifdef __cplusplus\n&#34;
						&#34;}\n&#34;
						&#34;#endif\n&#34;
						&#34;#endif /* UTHREADS_CWRAPPER_H_ */\n&#34;;

		OS.BodyOS&lt;&lt; &#34;#ifdef __cplusplus\n&#34;
						&#34;}\n&#34;
						&#34;#endif\n&#34;;

		OS.HeaderOS.flush();
		OS.BodyOS.flush();
		HOS&lt;&lt; OS.headerString &lt;&lt; &#34;\n&#34;;
		BOS&lt;&lt; OS.bodyString &lt;&lt; &#34;\n&#34;;

	}

	std::unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI,
			StringRef file) override {

		return llvm::make_unique&lt;MyASTConsumer&gt;(OS);
	}

private:
	OutputStreams OS;
};
</code></pre><p><code>MyFrontendAction</code> includes an instance of <code>OutputStreams</code> that has two string streams, one for the header file and the other one for the <code>.cpp</code> file. Both streams are intialized with the required include statements and <code>#ifdef</code> statements to be placed at the beginning of the file. The <code>EndSourceFileAction</code> is a callback at the end of processing a single input, and is used to append required strings to the end of the streams and save the streams to <code>cwrapper.h</code> and <code>cwrapper.cpp</code> files. Finally, <code>CreateASTConsumer</code> is called to create the AST consumer object for this action. Here an instance of <code>MyASTConsumer</code> is created and returned, we also pass the <code>OutputStreams</code> instance by reference, so later it can be passed to handlers. AST consumer, in our case, is responsible for registering matchers and run them over the AST. Here, the list of classes is used along with the <code>cxxMethodDecl</code> matcher we came up with earlier to match the methods of interest.</p><pre tabindex=0><code>// Implementation of the ASTConsumer interface for reading an AST produced
// by the Clang parser. It registers a couple of matchers and runs them on
// the AST.
class MyASTConsumer: public ASTConsumer {
public:
	MyASTConsumer(OutputStreams&amp; os) : OS(os),
			HandlerForClassMatcher(os){
		// Add a simple matcher for finding &#39;if&#39; statements.

		for(string&amp; className : ClassList){
			OS.HeaderOS &lt;&lt; &#34;struct      W&#34;&lt;&lt; className &lt;&lt; &#34;; \n&#34;
						   &#34;typedef     struct W&#34;&lt;&lt; className &lt;&lt; &#34; W&#34;&lt;&lt; className &lt;&lt; &#34;;\n&#34;;
			//oss.push_back(std::move(os))

			DeclarationMatcher classMatcher = cxxMethodDecl(isPublic(), ofClass(hasName(className))).bind(&#34;publicMethodDecl&#34;);
			Matcher.addMatcher(classMatcher, &amp;HandlerForClassMatcher);
		}

	}

	void HandleTranslationUnit(ASTContext &amp;Context) override {
		// Run the matchers when we have the whole TU parsed.
		Matcher.matchAST(Context);
	}

private:
	OutputStreams&amp; OS;
	classMatchHandler HandlerForClassMatcher;

	MatchFinder Matcher;
};
</code></pre><p><code>MyASTConsumer</code> has an instance of a <code>classMatchHandler</code> and a <code>MatchFinder</code>. <code>MatchFinder</code> is used to register matchers and handlers and to apply the matchers to AST Context and call the related handlers when a match is found. In the constructor, we add all the matchers using <code>addMatcher</code>, and under the <code>HandleTranslationUnit</code> we call <code>matchAST</code> to perform the matches and do the callbacks. We also bind the match to a string (<code>publicMethodDecl</code>), which is used later to differentiate among matchers. Also, notice that for each class a struct is generated with name <code>WclassName</code> along with a typedef with the same name. As explained eariler, this struct is used to hold a pointer to the instance of the class in C.</p><p>Class <code>classMatchHandler</code> is a child of <code>MatchFinder::MatchCallBack</code> class, and is used to perform the required task after a match is found. We also override member function <code>run</code>, that accepts a <code>MatchResult</code> and is called upon finding a match. The first step is to check whether the matched node with the provided string <code>publicMethodDecl</code> is of type <code>cxxMethodDecl</code>.</p><pre tabindex=0><code>if (const CXXMethodDecl *cmd = Result.Nodes.getNodeAs&lt;CXXMethodDecl&gt;(&#34;publicMethodDecl&#34;)){
			string methodName = &#34;&#34;;
			string className = cmd-&gt;getParent()-&gt;getDeclName().getAsString();
			string returnType = &#34;&#34;;
			string returnCast = &#34;&#34;;
			bool shouldReturn, isPointer;
			string self = &#34;W&#34; + className + &#34;* self&#34;;
			string separator = &#34;, &#34;;
			string bodyEnd = &#34;&#34;;

			std::stringstream functionBody;
</code></pre><p>If so, we create a few of strings variables in order to generate the final C method. <code>className</code> captures the name of the parent class of the method, i.e. the name used to find the method in the matcher, by getting the declaration name of the parent class as string. To map member functions to C, there is a need to send the pointer to the object as the first argument, so the string <code>self</code> contains the string that represents the pointer to the struct in C that is named as <em>self</em>. The rest of the variables are explained later.</p><p>As explained eariler, operator overloading is ignored and not mapped to C, thus:</p><pre tabindex=0><code>//ignore operator overloadings
if(cmd-&gt;isOverloadedOperator())
  return;
</code></pre><p>Next, we check whether the matched method is a constructor:</p><pre tabindex=0><code>//constructor
if (const CXXConstructorDecl* ccd = dyn_cast&lt;CXXConstructorDecl&gt;(cmd)) {
  if(ccd-&gt;isCopyConstructor() || ccd-&gt;isMoveConstructor()) return;
  methodName = &#34;_create&#34;;
  returnType = &#34;W&#34; + className + &#34;*&#34;;
  self = &#34;&#34;;
  separator = &#34;&#34;;
  functionBody &lt;&lt; &#34;return reinterpret_cast&lt;&#34;&lt;&lt; returnType &lt;&lt; &#34;&gt;( new &#34; &lt;&lt; className &lt;&lt; &#34;(&#34;;
  bodyEnd += &#34;))&#34;;
</code></pre><p>If <code>cmd</code> can be dynamically casted to <code>CXXConstructorDecl</code>, it means the method is a constructor. If the constructor is a copy constructor or move constructor we are not going to map it to C as explained above. The final method name should be <code>className_create</code>, so we set the <code>methodName</code> to be <code>_create</code> and later concatenate it to the calss name. Also, since the constructor creates an instance of the object and return a pointer to the created object, the return type should be the same as the struct type that holds the pointer to the object in C. <code>self</code> string will be empty, since there is no instance of the object yet to be passed to the constructor. <code>separator</code> is used to separate function arguments in the string, and since there is no self, the next argument do not need a comma before it. <code>functionBody</code> is a string stream that holds the information related to the function definition. For the constructor, we know that it returns the casted pointer to the object created by <code>new</code>, so the related string is generated accordingly. <code>bodyEnd</code> holds the string to complete the function definition, and since there are two open parentheses, they should be closed after arguments are placed in between the parentheses.</p><p>Next, we check wether the method is a destructor:</p><pre tabindex=0><code>}else if (isa&lt;CXXDestructorDecl&gt;(cmd)) {
methodName = &#34;_destroy&#34;;
returnType = &#34;void&#34;;
functionBody &lt;&lt; &#34; delete reinterpret_cast&lt;&#34;&lt;&lt;className &lt;&lt; &#34;*&gt;(self)&#34;;
</code></pre><p>If the method declaration <code>isa&lt;CXXDestructorDecl></code>, it means the method is a destructor. Thus, the <code>methodName</code> should be <code>_destroy</code>, <code>returnType</code> should be void, and <code>functionBody</code> just calls <code>delete</code> on the casted pointer.</p><p>If the method is not a constructor, destructor, or overloaded operator, it is a member or static function:</p><pre tabindex=0><code>}else{
  methodName = &#34;_&#34; + cmd-&gt;getNameAsString();
  const QualType qt = cmd-&gt;getReturnType();
  std::tie(returnType, returnCast, isPointer, shouldReturn) = determineCType(qt);

  //should this function return?
  if(shouldReturn)
  	functionBody &lt;&lt; &#34;return &#34;;

  if(returnCast != &#34;&#34;){
  	//if not pointer and it needs to be casted, then return the pointer
  	if(!isPointer)
  		functionBody &lt;&lt; &#34;&amp;&#34;;
  	functionBody &lt;&lt; &#34;reinterpret_cast&lt;&#34;&lt;&lt; returnType &lt;&lt; &#34;&gt;(&#34;;
  	bodyEnd += &#34;)&#34;;
  }

  //if Static call it properly
  if(cmd-&gt;isStatic())
  	functionBody &lt;&lt;className &lt;&lt; &#34;::&#34; &lt;&lt; cmd-&gt;getNameAsString() &lt;&lt; &#34;(&#34;;
  //if not  use the passed object to call the method
  else
  	functionBody &lt;&lt; &#34;reinterpret_cast&lt;&#34;&lt;&lt;className&lt;&lt;&#34;*&gt;(self)-&gt;&#34; &lt;&lt; cmd-&gt;getNameAsString() &lt;&lt; &#34;(&#34;;

  bodyEnd += &#34;)&#34;;
}
</code></pre><p>The <code>methodName</code> in this case is the same as the name of the method with prefix <code>_</code>. Next step is to determine what is the return type of the method, for that purpose we use <code>getReturnType</code> to find the <code>QualType</code>. Then, we pass the <code>QualType</code> to the helper function <code>determineCType</code>, in order to find the type, whether it needs casting, whether it&rsquo;s a pointer and whether it&rsquo;s a void type. Here is the definition of the <code>determineCType</code> function:</p><pre tabindex=0><code>tuple&lt;string, string, bool, bool&gt; determineCType(const QualType&amp; qt){

  string CType = &#34;&#34;;
  string CastType = &#34;&#34;; //whether this should be casted or not
  bool 	isPointer = false;
  bool 	shoulReturn = true;

  //if it is builtin type use it as is
  if(qt-&gt;isBuiltinType() || (qt-&gt;isPointerType() &amp;&amp; qt-&gt;getPointeeType()-&gt;isBuiltinType())){
    CType = qt.getAsString();
    if(qt-&gt;isVoidType())
      shoulReturn = false;
  //if it is a CXXrecordDecl then return a pointer to WName*
  }else if(qt-&gt;isRecordType()){
    const CXXRecordDecl* crd = qt-&gt;getAsCXXRecordDecl();
    string recordName = crd-&gt;getNameAsString();
    CType = &#34;W&#34; + recordName + &#34;*&#34;;
    CastType = recordName+ &#34;*&#34;;

  }else if( (qt-&gt;isReferenceType() || qt-&gt;isPointerType()) &amp;&amp; qt-&gt;getPointeeType()-&gt;isRecordType()){
    isPointer = true; //to properly differentiate among cast types
    const CXXRecordDecl* crd = qt-&gt;getPointeeType()-&gt;getAsCXXRecordDecl();
    string recordName = crd-&gt;getNameAsString();
    if ( std::find(ClassList.begin(), ClassList.end(), recordName) != ClassList.end() ){
      CType = &#34;W&#34; + recordName + &#34;*&#34;;
      CastType = recordName + &#34;*&#34;;
    }else{
      CType = recordName+&#34;*&#34;;
    }

  }
  return make_tuple(CType, CastType, isPointer, shoulReturn);

}
</code></pre><p>This function returns 4 variables; one that reperesents the type that should be returned, one that shows what the return type should be casted from, and two booleans reperesenting whether the type is a pointer and whether the function needs a <code>return</code> statement before the function call. First, if the type is a builtin type, or is a pointer to a builtin type, there is no need to cast it (castType is left empty), and if this builtin type is <code>void</code> there is no need to put the <code>return</code> keyword before calling the function. Otherwise, if the type is a record type (class or struct), since in uThreads all functions only return record types that is defined whitin uThreads library, we can be sure that by casting the return type to <code>WclassName</code> struct, we are returning the instance of the object (it can be problematic if the returned object needs to be copied, since the original memory might be freed at the end of the function and the returned pointer is not valid anymore. But since in uThreads all objects are returned either by reference or only pointers are being returned, this condition does not apply to uThreads. Thus, it should be modified if you need to use it in another projects. This part is mainly relevant for function arguments, when later <code>determineCType</code> is called to determine the type of the passed arguments). Finally, if the return type is a pointer or reference to a record type, and the pointer is to a class under the uThreads list of classes, return the <code>WclassName*</code>, otherwise return the pointer itself.</p><p>Continuing on determining the return type, if the <code>shouldRetran</code> flag is true, a <code>return</code> keyword is added before the function call. If the return variable requires casting, insert <code>reinterpret_cast</code> along with the C return type before calling the function. Finally, generate the function call: if the function is static, call it by using <code>className::methodName</code>, and if not use <code>reinterpret_cast</code> to cast the passed <code>self</code> pointer to the object pointer and call the function by <code>self->methodName</code>.</p><p>Next, let&rsquo;s generate the function declaration in C by concatenating the related strings together:</p><pre tabindex=0><code>std::stringstream funcname;
funcname &lt;&lt; returnType &lt;&lt; &#34; &#34; &lt;&lt; className &lt;&lt; methodName;

auto it = funcList.find(funcname.str());

if(it != funcList.end()){
	it-&gt;second++;
	funcname &lt;&lt; &#34;_&#34; &lt;&lt; it-&gt;second ;
}else{
	funcList[funcname.str()] = 0;
}

funcname &lt;&lt; &#34;(&#34; &lt;&lt; self;
</code></pre><p>Function name is of form <code>returnType className_methodName</code> in C. In addition, as explained earlier, if there is any function overloading, a number is added to the end of the function name. Thus, a map of function names to integer is used to keep track of the number of times the function of the specified class appeared. If it appears more than one time, a suffix <code>_n</code> is added to the end of the function, where <code>n</code> is the number of times the function appeared. Finally, we add a parentheses to the end of the function name, along with the <code>self</code> string, that reperesnts whether a pointer to the object is passed to the function or not, and start generating the argument list:</p><pre tabindex=0><code>for(unsigned int i=0; i&lt;cmd-&gt;getNumParams(); i++)
{
  const QualType qt = cmd-&gt;parameters()[i]-&gt;getType();
  std::tie(returnType, returnCast, isPointer, shouldReturn) = determineCType(qt);
  funcname &lt;&lt; separator &lt;&lt; returnType &lt;&lt; &#34; &#34;;
  funcname &lt;&lt; cmd-&gt;parameters()[i]-&gt;getQualifiedNameAsString() &lt;&lt; &#34;&#34;;

  if(i !=0 )
    functionBody &lt;&lt; separator;
  if(returnCast == &#34;&#34;)
    functionBody &lt;&lt; cmd-&gt;parameters()[i]-&gt;getQualifiedNameAsString();
  else{
    if(!isPointer)
      functionBody &lt;&lt; &#34;*&#34;;
    functionBody &lt;&lt; &#34;reinterpret_cast&lt;&#34; &lt;&lt; returnCast &lt;&lt; &#34;&gt;(&#34;&lt;&lt; cmd-&gt;parameters()[i]-&gt;getQualifiedNameAsString() &lt;&lt; &#34;)&#34;;

  }

  string separator = &#34;, &#34;;
}
</code></pre><p>To generate the argument list in C, we iterate through the method arguments by using <code>getNumParams</code> and <code>parameters</code> array. The type of the argument in C is determined by calling to <code>determineCType</code>, and based on the tpe of the argument it might require casting. After generating the list of the arguments, we simply close the parentheses and print the generated function name and body in header and body string streams:</p><pre tabindex=0><code>funcname &lt;&lt; &#34;)&#34;;

OS.HeaderOS &lt;&lt; funcname.str() &lt;&lt; &#34;;\n&#34;;

OS.BodyOS &lt;&lt; funcname.str() &lt;&lt; &#34;{\n    &#34;;
OS.BodyOS &lt;&lt; functionBody.str();
OS.BodyOS &lt;&lt; bodyEnd &lt;&lt; &#34;; \n}\n&#34; ;
</code></pre><p>As explained earlier, <code>BodyOS</code> and <code>HeaderOS</code> streams are flushed to related files in the end. To build and install the binary simply clone the repo and issue the following commands (you require cmake and make to be installed):</p><pre tabindex=0><code>git clone https://github.com/samanbarghi/CPP2C
cd CPP2C
mkdir build
cmake ..
make
sudo make install
</code></pre><p>The binary is installed under <code>/usr/local/bin</code> and you can use it under the uThreads directory as follows:</p><pre tabindex=0><code>git clone https://github.com/samanbarghi/uThreads
cd uThreads
cpp2c include/uThreads.h -- -I./src -std=c++11
</code></pre><p><code>cpp2c</code> creates two files <code>cwrapper.h</code> and <code>cwrapper.cpp</code> that holds the generated C interface. You can find the generated file <a href=https://github.com/samanbarghi/CPP2C/tree/master/output>here</a>.</p><p>Another issue with current approach is in cases where there is no public constructor (e.g., uThread class does not have a public constructor and uThread instances are created using uThreads::create function) the content of the constructor is going to be wrong and need to be updated. A possible fix that can further improve the current approach is to annotate the C++ source code with the intended C interface, and in cases the annotation is used simply use the annotation instead of generating the function.</p><p>Although the C interface generator still has some shortcomings when it comes to return types, dealing with template functions and out of uThreads classes, this practice shows the potential of using such approach to automate the generation of C interfaces from C++ source code, specially for large projects.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=http://samanbarghi.com/post/2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux/><span class=title>Next »</span><br><span>How to wrap a system call (libc function) in Linux</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Generate C interface from C++ source code using Clang libtooling on twitter" href="https://twitter.com/intent/tweet/?text=Generate%20C%20interface%20from%20C%2b%2b%20source%20code%20using%20Clang%20libtooling&url=http%3a%2f%2fsamanbarghi.com%2fpost%2fusing-clang-libtooling-to-generate-c-interface-from-c%2b%2b-source-code%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Generate C interface from C++ source code using Clang libtooling on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fsamanbarghi.com%2fpost%2fusing-clang-libtooling-to-generate-c-interface-from-c%2b%2b-source-code%2f&title=Generate%20C%20interface%20from%20C%2b%2b%20source%20code%20using%20Clang%20libtooling&summary=Generate%20C%20interface%20from%20C%2b%2b%20source%20code%20using%20Clang%20libtooling&source=http%3a%2f%2fsamanbarghi.com%2fpost%2fusing-clang-libtooling-to-generate-c-interface-from-c%2b%2b-source-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Generate C interface from C++ source code using Clang libtooling on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fsamanbarghi.com%2fpost%2fusing-clang-libtooling-to-generate-c-interface-from-c%2b%2b-source-code%2f&title=Generate%20C%20interface%20from%20C%2b%2b%20source%20code%20using%20Clang%20libtooling"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Generate C interface from C++ source code using Clang libtooling on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fsamanbarghi.com%2fpost%2fusing-clang-libtooling-to-generate-c-interface-from-c%2b%2b-source-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Generate C interface from C++ source code using Clang libtooling on whatsapp" href="https://api.whatsapp.com/send?text=Generate%20C%20interface%20from%20C%2b%2b%20source%20code%20using%20Clang%20libtooling%20-%20http%3a%2f%2fsamanbarghi.com%2fpost%2fusing-clang-libtooling-to-generate-c-interface-from-c%2b%2b-source-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Generate C interface from C++ source code using Clang libtooling on telegram" href="https://telegram.me/share/url?text=Generate%20C%20interface%20from%20C%2b%2b%20source%20code%20using%20Clang%20libtooling&url=http%3a%2f%2fsamanbarghi.com%2fpost%2fusing-clang-libtooling-to-generate-c-interface-from-c%2b%2b-source-code%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://samanbarghi.com/>Saman Barghi</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>