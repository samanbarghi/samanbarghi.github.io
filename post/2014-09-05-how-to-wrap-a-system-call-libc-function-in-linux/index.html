<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to wrap a system call (libc function) in Linux | Saman Barghi</title><meta name=keywords content><meta name=description content="For one of my research projects I had to wrap linux system calls and redirect them to another thread. In Linux system calls are not invoked directly, but rather via wrapper functions in glibc[man 2 syscalls]. The glibc wrapper is only copying arguments and unique system call number to the registers where the kernel expects them, then trapping to kernel mode and setting the errno if the system call returns an error number [man 2 intro]."><meta name=author content="Saman Barghi"><link rel=canonical href=http://samanbarghi.com/post/2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://samanbarghi.com/images/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://samanbarghi.com/images/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://samanbarghi.com/images/favicon/favicon-32x32.png><link rel=apple-touch-icon href=http://samanbarghi.com/images/favicon/apple-touch-icon.png><link rel=mask-icon href=http://samanbarghi.com/images/favicon/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-48282777-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="How to wrap a system call (libc function) in Linux"><meta property="og:description" content="For one of my research projects I had to wrap linux system calls and redirect them to another thread. In Linux system calls are not invoked directly, but rather via wrapper functions in glibc[man 2 syscalls]. The glibc wrapper is only copying arguments and unique system call number to the registers where the kernel expects them, then trapping to kernel mode and setting the errno if the system call returns an error number [man 2 intro]."><meta property="og:type" content="article"><meta property="og:url" content="http://samanbarghi.com/post/2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux/"><meta property="og:image" content="http://samanbarghi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-09-05T00:00:00+00:00"><meta property="article:modified_time" content="2014-09-05T00:00:00+00:00"><meta property="og:site_name" content="Saman Barghi"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://samanbarghi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="How to wrap a system call (libc function) in Linux"><meta name=twitter:description content="For one of my research projects I had to wrap linux system calls and redirect them to another thread. In Linux system calls are not invoked directly, but rather via wrapper functions in glibc[man 2 syscalls]. The glibc wrapper is only copying arguments and unique system call number to the registers where the kernel expects them, then trapping to kernel mode and setting the errno if the system call returns an error number [man 2 intro]."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://samanbarghi.com/post/"},{"@type":"ListItem","position":2,"name":"How to wrap a system call (libc function) in Linux","item":"http://samanbarghi.com/post/2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to wrap a system call (libc function) in Linux","name":"How to wrap a system call (libc function) in Linux","description":"For one of my research projects I had to wrap linux system calls and redirect them to another thread. In Linux system calls are not invoked directly, but rather via wrapper functions in glibc[man 2 syscalls]. The glibc wrapper is only copying arguments and unique system call number to the registers where the kernel expects them, then trapping to kernel mode and setting the errno if the system call returns an error number [man 2 intro].","keywords":[],"articleBody":"For one of my research projects I had to wrap linux system calls and redirect them to another thread. In Linux system calls are not invoked directly, but rather via wrapper functions in glibc[man 2 syscalls]. The glibc wrapper is only copying arguments and unique system call number to the registers where the kernel expects them, then trapping to kernel mode and setting the errno if the system call returns an error number [man 2 intro].\nIt is possible to invoke system calls directly by using syscall [man 2 syscall]. But since most programs will rely on glibc functions for system calls, it will be enough to wrap those functions. There are two ways to wrap or override C functions in Linux:\nUsing LD_PRELOAD: There is a shell environment variable in Linux called LD_PRELOAD, which can be set to a path of a shared library, and that library will be loaded before any other library (including glibc). Using ’ld --wrap=symbol’: This can be used to use a wrapper function for symbol. Any further reference to symbol will be resolved to the wrapper function. [man 1 ld]. I explain each approach later, but first lets write a very simple test file. I plan to wrap write system call and count the total number of characters that is being written out.\nTest file Lets write a very simple test file that calls write and printf to write to standard output:\n#include #include int main() { write(0, \"Hello, Kernel!\\n\", 15); printf(\"Hello, World!\\n\"); return 0; } If I run the code I get:\n$ ./bin/test Hello, Kernel! Hello, World! Now I want to see what are the system calls that are being called when running the test file. I use strace to see the system calls responsible for writting to the standard output. strace is being used to trace system calls and signals. Here is the result:\nexecve(\"./bin/test\", [\"./bin/test\"], [/* 53 vars */]) = 0 brk(0) = 0x2532000 access(\"/etc/ld.so.nohwcap\", F_OK) = -1 ENOENT (No such file or directory) mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f099cc04000 access(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory) open(\"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3 fstat(3, {st_mode=S_IFREG|0644, st_size=128624, ...}) = 0 mmap(NULL, 128624, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f099cbe4000 close(3) = 0 access(\"/etc/ld.so.nohwcap\", F_OK) = -1 ENOENT (No such file or directory) open(\"/lib/x86_64-linux-gnu/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3 read(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\u003e\\0\\1\\0\\0\\0\\320\\37\\2\\0\\0\\0\\0\\0\"..., 832) = 832 fstat(3, {st_mode=S_IFREG|0755, st_size=1845024, ...}) = 0 mmap(NULL, 3953344, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f099c61e000 mprotect(0x7f099c7d9000, 2097152, PROT_NONE) = 0 mmap(0x7f099c9d9000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bb000) = 0x7f099c9d9000 mmap(0x7f099c9df000, 17088, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f099c9df000 close(3) = 0 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f099cbe3000 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f099cbe1000 arch_prctl(ARCH_SET_FS, 0x7f099cbe1740) = 0 mprotect(0x7f099c9d9000, 16384, PROT_READ) = 0 mprotect(0x600000, 4096, PROT_READ) = 0 mprotect(0x7f099cc06000, 4096, PROT_READ) = 0 munmap(0x7f099cbe4000, 128624) = 0 write(0, \"Hello, Kernel!\\n\", 15Hello, Kernel!) = 15 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 3), ...}) = 0 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f099cc03000 write(1, \"Hello, World!\\n\", 14Hello, World!) = 14 exit_group(0) = ? +++ exited with 0 +++ As you can see lines 26 and 29 are where the write system call related to our code is being called. Since our goal is to wrap glibc functions, lets check output of ltrace as well. ltrace intercepts and records the dynamic library calls which are called by the executed process [man 1 ltrace]. Here is the result:\n__libc_start_main(0x40057d, 1, 0x7fffdd1ec628, 0x4005b0 write(0, \"Hello, Kernel!\\n\", 15Hello, Kernel! ) = 15 puts(\"Hello, World!\"Hello, World!) = 14 +++ exited (status 0) +++ ltrace result shows that the write function in the code is calling the write function from glibc, but printf is calling puts from glibc. So we should be careful here, overriding only the write function from glibc will not cause the write system call from printf to be wrapped. We need to differentiate between the final system call and the glibc library call. So in order to cover both of the cases, I need to override write and puts functions. Now lets jump into wrapping these functions.\nUsing LD_PRELOAD LD_PRELOAD allows a shared library to be loaded before any other libraries. So all I need to do is to write a shared library that overrides write and puts functions. If we wrap these functions, we need a way to call the real functions to perform the system call. dlsym just do that for us [man 3 dlsym]:\nThe function dlsym() takes a “handle” of a dynamic library returned by dlopen() and the null-terminated symbol name, returning the address where that symbol is loaded into memory. If the symbol is not found, in the specified library or any of the libraries that were automatically loaded by dlopen() when that library was loaded, dlsym() returns NULL…\nSo inside the wrapper function we can use dlsym to get the address of the related symbol in memory and call the glibc function. Another approach can be calling the syscall directly, both approaches will work. Here is the code:\n#define _GNU_SOURCE #include #include #include /* Function pointers to hold the value of the glibc functions */ static ssize_t (*real_write)(int fd, const void *buf, size_t count) = NULL; static int (*real_puts)(const char* str) = NULL; /* wrapping write function call */ ssize_t write(int fd, const void *buf, size_t count) { /* printing out the number of characters */ printf(\"write:chars#:%lu\\n\", count); /* reslove the real write function from glibc * and pass the arguments. */ real_write = dlsym(RTLD_NEXT, \"write\"); real_write(fd, buf, count); } int puts(const char* str) { /* printing out the number of characters */ printf(\"puts:chars#:%lu\\n\", strlen(str)); /* resolve the real puts function from glibc * and pass the arguments. */ real_puts = dlsym(RTLD_NEXT, \"puts\"); real_puts(str); } We first declare pointers to hold the value of the glibc functions, we will use these later to get the pointer from dlsym. Then we simply implement the glibc functions that we want to wrap, add our code and finally call the real function to perform the intended task.\nCompiling the shared library We compile the shared library as follows:\ngcc -fPIC -shared -o bin/libpreload.so src/wrap-preload.c -ldl We need to make sure we are generating a position-independent code(PIC) by passing -fPIC that is shared -shared. We also need to link our library with Dynamically Loaded (DL) libraries -ldl, since we are using dlsym in our code.\nTo run our test code and wrap glibc functions, we simply set LD_PRELOAD enviornment variable to the generated shared object file:\n$ LD_PRELOAD=/home/saman/Programming/wrap-syscall/bin/libpreload.so ./bin/test write:chars#:15 Hello, Kernel! puts:chars#:13 Hello, World! LD_PRELOAD loads the libpreload.so library before the execution of our code, and thus calling write and puts will call our wrapper functions inside the library.\nUsing ld --wrap=symbol Another way of wrapping functions is by using linker at the link time. GNU linker provides an option to wrap a function for a symbol [man 1 ld]:\nUse a wrapper function for symbol. Any undefined reference to symbol will be resolved to “__wrap_symbol”. Any undefined reference to “__real_symbol” will be resolved to symbol.\nThis can be used to provide a wrapper for a system function. The wrapper function should be called “__wrap_symbol”. If it wishes to call the system function, it should call “__real_symbol”.\nHere is a trivial example:\nvoid * __wrap_malloc (size_t c) { printf (\"malloc called with %zu\\n\", c); return __real_malloc (c); } If you link other code with this file using –wrap malloc, then all calls to “malloc” will call the function “__wrap_malloc” instead. The call to “__real_malloc” in “__wrap_malloc” will call the real “malloc” function.\nYou may wish to provide a “__real_malloc” function as well, so that links without the –wrap option will succeed. If you do this, you should not put the definition of “__real_malloc” in the same file as “__wrap_malloc”; if you do, the assembler may resolve the call before the linker has a chance to wrap it to “malloc”.\nBased on the description, we need to implement two function __real_symbol and __wrap_symbol (in our case __real_write and __wrap_write), and link the application with our code. Here is the code:\n#include #include /* create pointers for real glibc functions */ ssize_t __real_write(int fd, const void *buf, size_t count); int __real_puts(const char* str); /* wrapping write function */ ssize_t __wrap_write (int fd, const void *buf, size_t count) { /* printing out the number of characters */ printf(\"write:chars#:%lu\\n\", count); /* call the real glibc function and return the result */ ssize_t result = __real_write(fd, buf, count); return result; } /* wrapping puts function */ int __wrap_puts (const char* str) { /* printing out the number of characters */ printf(\"puts:chars#:%lu\\n\", strlen(str)); /* call the real glibc function and return the result */ int result = __real_puts(str); return result; } The code is very straight forward, but now lets try to compile the code and link it with our test application.\ngcc -c src/wrap-link.c -o bin/wrap-link.o gcc -c src/test.c -o bin/test-link.o gcc -Wl,-wrap,write -Wl,-wrap=write -Wl,-wrap=puts bin/test-link.o bin/wrap-link.o -o bin/test-link-bin I used gcc to pass the option to the linker with -Wl, which is equal to calling ld with --wrap option. Now if I run the code I get:\n$ ./bin/test-link-bin write:chars#:15 Hello, Kernel! puts:chars#:13 Hello, World! Conclusion In order to wrap system calls in Linux, one have to wrap related glibc function calls. You have to be careful about the type of system calls you are tryting to override, since various functions might call different functions from glibc, e.g. printf calls puts from glibc which calls write at the end.\nThere are two ways to do this: 1-Using LD_PRELOAD environment variable, 2-using ld --wrap. I personally prefer the first approach since if the number of wrapper functions increases I do not have to specify them one by one, as in the second case.\nYou can find the source code and the related Makefile in the following github repository: https://github.com/samanbarghi/wrap-syscall.\n","wordCount":"1642","inLanguage":"en","datePublished":"2014-09-05T00:00:00Z","dateModified":"2014-09-05T00:00:00Z","author":{"@type":"Person","name":"Saman Barghi"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://samanbarghi.com/post/2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux/"},"publisher":{"@type":"Organization","name":"Saman Barghi","logo":{"@type":"ImageObject","url":"http://samanbarghi.com/images/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://samanbarghi.com/ accesskey=h title="Home (Alt + H)"><img src=http://samanbarghi.com/images/favicon/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://samanbarghi.com/about/ title=about><span>about</span></a></li><li><a href=http://samanbarghi.com/projects/ title=projects><span>projects</span></a></li><li><a href=http://samanbarghi.com/categories/ title=categories><span>categories</span></a></li><li><a href=http://samanbarghi.com/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://samanbarghi.com/>Home</a>&nbsp;»&nbsp;<a href=http://samanbarghi.com/post/>Posts</a></div><h1 class=post-title>How to wrap a system call (libc function) in Linux</h1><div class=post-meta><span title='2014-09-05 00:00:00 +0000 UTC'>September 5, 2014</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1642 words&nbsp;·&nbsp;Saman Barghi&nbsp;|&nbsp;<a href=https://github.com/samanbarghi/samanbarghi-hugo/tree/master/content/post/2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>For one of my research projects I had to wrap linux system calls and redirect
them to another thread. In Linux system calls are not invoked directly, but
rather via wrapper functions in
glibc[<a href=http://man7.org/linux/man-pages/man2/syscalls.2.html>man 2 syscalls</a>]. The glibc
wrapper is only copying arguments and unique system call number to the registers
where the kernel expects them, then trapping to kernel mode and setting the
errno if the system call returns an error number [<a href=http://man7.org/linux/man-pages/man2/intro.2.html>man 2 intro</a>].</p><p>It is possible to invoke system calls directly by using syscall [<a href=http://man7.org/linux/man-pages/man2/syscall.2.html>man 2 syscall</a>]. But since most programs will rely on glibc functions for system calls, it will be enough to wrap those functions. There are two ways to wrap or override C functions in Linux:</p><ul><li><strong>Using LD_PRELOAD:</strong> There is a shell environment variable in Linux called
<em>LD_PRELOAD</em>, which can be set to a path of a shared library, and that library
will be loaded before any other library (including glibc).</li><li><strong>Using &rsquo;ld --wrap=<em>symbol</em>&rsquo;:</strong> This can be used to use a wrapper function
for <em>symbol</em>. Any further reference to <em>symbol</em> will be resolved to the
wrapper function. [<a href=http://man7.org/linux/man-pages/man1/ld.1.html>man 1 ld</a>].</li></ul><p>I explain each approach later, but first lets write a very simple test file.
I plan to wrap <em>write</em> system call and count the total number of characters that
is being written out.</p><h3 id=test-file>Test file<a hidden class=anchor aria-hidden=true href=#test-file>#</a></h3><p>Lets write a very simple test file that calls <em>write</em> and <em>printf</em> to write to standard output:</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    write(0, &#34;Hello, Kernel!\n&#34;, 15);
    printf(&#34;Hello, World!\n&#34;);

    return 0;
}
</code></pre><p>If I run the code I get:</p><pre tabindex=0><code>$ ./bin/test
Hello, Kernel!
Hello, World!
</code></pre><p>Now I want to see what are the system calls that are being called when running the test file. I use <em>strace</em> to see the system calls responsible for writting to the standard output. <em>strace</em> is being used to trace system calls and signals. Here is the result:</p><pre tabindex=0><code>execve(&#34;./bin/test&#34;, [&#34;./bin/test&#34;], [/* 53 vars */]) = 0
brk(0)                                  = 0x2532000
access(&#34;/etc/ld.so.nohwcap&#34;, F_OK)      = -1 ENOENT (No such file or directory)
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f099cc04000
access(&#34;/etc/ld.so.preload&#34;, R_OK)      = -1 ENOENT (No such file or directory)
open(&#34;/etc/ld.so.cache&#34;, O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=128624, ...}) = 0
mmap(NULL, 128624, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f099cbe4000
close(3)                                = 0
access(&#34;/etc/ld.so.nohwcap&#34;, F_OK)      = -1 ENOENT (No such file or directory)
open(&#34;/lib/x86_64-linux-gnu/libc.so.6&#34;, O_RDONLY|O_CLOEXEC) = 3
read(3, &#34;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\320\37\2\0\0\0\0\0&#34;..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=1845024, ...}) = 0
mmap(NULL, 3953344, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f099c61e000
mprotect(0x7f099c7d9000, 2097152, PROT_NONE) = 0
mmap(0x7f099c9d9000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bb000) = 0x7f099c9d9000
mmap(0x7f099c9df000, 17088, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f099c9df000
close(3)                                = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f099cbe3000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f099cbe1000
arch_prctl(ARCH_SET_FS, 0x7f099cbe1740) = 0
mprotect(0x7f099c9d9000, 16384, PROT_READ) = 0
mprotect(0x600000, 4096, PROT_READ)     = 0
mprotect(0x7f099cc06000, 4096, PROT_READ) = 0
munmap(0x7f099cbe4000, 128624)          = 0
write(0, &#34;Hello, Kernel!\n&#34;, 15Hello, Kernel!)        = 15
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 3), ...}) = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f099cc03000
write(1, &#34;Hello, World!\n&#34;, 14Hello, World!)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++
</code></pre><p>As you can see lines 26 and 29 are where the <em>write</em> system call related to our
code is being called. Since our goal is to wrap glibc functions, lets check
output of <em>ltrace</em> as well. <em>ltrace</em> intercepts and records the dynamic library
calls which are called by the executed process [<a href=http://man7.org/linux/man-pages/man1/ltrace.1.html>man 1 ltrace</a>]. Here is the result:</p><pre tabindex=0><code>__libc_start_main(0x40057d, 1, 0x7fffdd1ec628, 0x4005b0 &lt;unfinished ...&gt;
write(0, &#34;Hello, Kernel!\n&#34;, 15Hello, Kernel!
)                                          = 15
puts(&#34;Hello, World!&#34;Hello, World!)         = 14
+++ exited (status 0) +++
</code></pre><p><em>ltrace</em> result shows that the <em>write</em> function in the code is calling the
<em>write</em> function from glibc, but <em>printf</em> is calling <em>puts</em> from glibc. So we
should be careful here, overriding only the <em>write</em> function from glibc will not
cause the <em>write</em> system call from <em>printf</em> to be wrapped. We need to
differentiate between the final system call and the glibc library call. So in
order to cover both of the cases, I need to override <em>write</em> and <em>puts</em>
functions. Now lets jump into wrapping these functions.</p><h2 id=using-ld_preload>Using LD_PRELOAD<a hidden class=anchor aria-hidden=true href=#using-ld_preload>#</a></h2><p>LD_PRELOAD allows a shared library to be loaded before any other libraries. So
all I need to do is to write a shared library that overrides <em>write</em> and <em>puts</em>
functions. If we wrap these functions, we need a way to call the real functions
to perform the system call. <em>dlsym</em> just do that for us [<a href=http://man7.org/linux/man-pages/man3/dlsym.3.html>man 3 dlsym</a>]:</p><blockquote><p>The function dlsym() takes a &ldquo;handle&rdquo; of a dynamic library returned
by dlopen() and the null-terminated symbol name, returning the
address where that symbol is loaded into memory. If the symbol is
not found, in the specified library or any of the libraries that were
automatically loaded by dlopen() when that library was loaded,
dlsym() returns NULL&mldr;</p></blockquote><p>So inside the wrapper function we can use dlsym to get the address of the related symbol in memory and call the glibc function. Another approach can be calling the syscall directly, both approaches will work. Here is the code:</p><pre tabindex=0><code>#define _GNU_SOURCE
#include &lt;dlfcn.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/* Function pointers to hold the value of the glibc functions */
static  ssize_t (*real_write)(int fd, const void *buf, size_t count) = NULL;
static int (*real_puts)(const char* str) = NULL;

/* wrapping write function call */
ssize_t write(int fd, const void *buf, size_t count)
{

    /* printing out the number of characters */
    printf(&#34;write:chars#:%lu\n&#34;, count);
    /* reslove the real write function from glibc
     * and pass the arguments.
     */
    real_write = dlsym(RTLD_NEXT, &#34;write&#34;);
    real_write(fd, buf, count);

}

int puts(const char* str)
{

    /* printing out the number of characters */
    printf(&#34;puts:chars#:%lu\n&#34;, strlen(str));
    /* resolve the real puts function from glibc
     * and pass the arguments.
     */
    real_puts = dlsym(RTLD_NEXT, &#34;puts&#34;);
    real_puts(str);
}
</code></pre><p>We first declare pointers to hold the value of the glibc functions, we will use these later to get the pointer from <em>dlsym</em>. Then we simply implement the glibc functions that we want to wrap, add our code and finally call the real function to perform the intended task.</p><h4 id=compiling-the-shared-library>Compiling the shared library<a hidden class=anchor aria-hidden=true href=#compiling-the-shared-library>#</a></h4><p>We compile the shared library as follows:</p><pre tabindex=0><code>gcc -fPIC -shared  -o bin/libpreload.so src/wrap-preload.c -ldl
</code></pre><p>We need to make sure we are generating a position-independent code(PIC) by passing <code>-fPIC</code> that is shared <code>-shared</code>. We also need to link our library with Dynamically Loaded (DL) libraries <code>-ldl</code>, since we are using dlsym in our code.</p><p>To run our test code and wrap glibc functions, we simply set <code>LD_PRELOAD</code> enviornment variable to the generated shared object file:</p><pre tabindex=0><code>$ LD_PRELOAD=/home/saman/Programming/wrap-syscall/bin/libpreload.so ./bin/test
write:chars#:15
Hello, Kernel!
puts:chars#:13
Hello, World!
</code></pre><p><code>LD_PRELOAD</code> loads the libpreload.so library before the execution of our code, and thus calling <em>write</em> and <em>puts</em> will call our wrapper functions inside the library.</p><h2 id=using-ld---wrapsymbol>Using <em>ld --wrap=symbol</em><a hidden class=anchor aria-hidden=true href=#using-ld---wrapsymbol>#</a></h2><p>Another way of wrapping functions is by using linker at the link time. GNU linker provides an option to wrap a function for a symbol [<a href=http://man7.org/linux/man-pages/man1/ld.1.html>man 1 ld</a>]:</p><blockquote><p>Use a wrapper function for symbol. Any undefined reference to
symbol will be resolved to &ldquo;__wrap_symbol&rdquo;. Any undefined
reference to &ldquo;__real_symbol&rdquo; will be resolved to symbol.</p></blockquote><blockquote><p>This can be used to provide a wrapper for a system function. The
wrapper function should be called &ldquo;__wrap_symbol&rdquo;. If it wishes
to call the system function, it should call &ldquo;__real_symbol&rdquo;.</p></blockquote><blockquote><p>Here is a trivial example:</p></blockquote><blockquote><pre><code>   void *
   __wrap_malloc (size_t c)
   {
    printf (&quot;malloc called with %zu\n&quot;, c);
    return __real_malloc (c);
   }
</code></pre></blockquote><blockquote><p>If you link other code with this file using &ndash;wrap malloc, then
all calls to &ldquo;malloc&rdquo; will call the function &ldquo;__wrap_malloc&rdquo;
instead. The call to &ldquo;__real_malloc&rdquo; in &ldquo;__wrap_malloc&rdquo; will
call the real &ldquo;malloc&rdquo; function.</p></blockquote><blockquote><p>You may wish to provide a &ldquo;__real_malloc&rdquo; function as well, so
that links without the &ndash;wrap option will succeed. If you do
this, you should not put the definition of &ldquo;__real_malloc&rdquo; in the
same file as &ldquo;__wrap_malloc&rdquo;; if you do, the assembler may
resolve the call before the linker has a chance to wrap it to
&ldquo;malloc&rdquo;.</p></blockquote><p>Based on the description, we need to implement two function <code>__real_symbol</code> and <code>__wrap_symbol</code> (in our case <code>__real_write</code> and <code>__wrap_write</code>), and link the application with our code. Here is the code:</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/* create pointers for real glibc functions */
ssize_t __real_write(int fd, const void *buf, size_t count);
int __real_puts(const char* str);


/* wrapping write function */


ssize_t __wrap_write (int fd, const void *buf, size_t count)
{
    /* printing out the number of characters */
    printf(&#34;write:chars#:%lu\n&#34;, count);

    /* call the real glibc function and return the result */
    ssize_t result = __real_write(fd, buf, count);
    return result;
}

/* wrapping puts function */
int __wrap_puts (const char* str)
{
    /* printing out the number of characters */
    printf(&#34;puts:chars#:%lu\n&#34;, strlen(str));

    /* call the real glibc function and return the result */
    int result = __real_puts(str);
    return result;
}
</code></pre><p>The code is very straight forward, but now lets try to compile the code and link it with our test application.</p><pre tabindex=0><code>gcc -c src/wrap-link.c -o bin/wrap-link.o
gcc -c src/test.c -o bin/test-link.o
gcc -Wl,-wrap,write -Wl,-wrap=write -Wl,-wrap=puts bin/test-link.o bin/wrap-link.o -o bin/test-link-bin
</code></pre><p>I used <em>gcc</em> to pass the option to the linker with <code>-Wl</code>, which is equal to calling <code>ld</code> with <code>--wrap</code> option. Now if I run the code I get:</p><pre tabindex=0><code>$ ./bin/test-link-bin
write:chars#:15
Hello, Kernel!
puts:chars#:13
Hello, World!
</code></pre><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In order to wrap system calls in Linux, one have to wrap related glibc function calls. You have to be careful about the type of system calls you are tryting to override, since various functions might call different functions from glibc, e.g. <em>printf</em> calls <em>puts</em> from glibc which calls <em>write</em> at the end.</p><p>There are two ways to do this: 1-Using <code>LD_PRELOAD</code> environment variable, 2-using <code>ld --wrap</code>. I personally prefer the first approach since if the number of wrapper functions increases I do not have to specify them one by one, as in the second case.</p><p>You can find the source code and the related Makefile in the following github repository: <a href=wrap-syscall>https://github.com/samanbarghi/wrap-syscall</a>.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://samanbarghi.com/post/using-clang-libtooling-to-generate-c-interface-from-c++-source-code/><span class=title>« Prev</span><br><span>Generate C interface from C++ source code using Clang libtooling</span></a>
<a class=next href=http://samanbarghi.com/2012/08/29/national-geographic-photo-of-the-day-downloader-for-linux/><span class=title>Next »</span><br><span>National Geographic Photo of the day Downloader for Linux</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share How to wrap a system call (libc function) in Linux on twitter" href="https://twitter.com/intent/tweet/?text=How%20to%20wrap%20a%20system%20call%20%28libc%20function%29%20in%20Linux&url=http%3a%2f%2fsamanbarghi.com%2fpost%2f2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to wrap a system call (libc function) in Linux on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fsamanbarghi.com%2fpost%2f2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux%2f&title=How%20to%20wrap%20a%20system%20call%20%28libc%20function%29%20in%20Linux&summary=How%20to%20wrap%20a%20system%20call%20%28libc%20function%29%20in%20Linux&source=http%3a%2f%2fsamanbarghi.com%2fpost%2f2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to wrap a system call (libc function) in Linux on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fsamanbarghi.com%2fpost%2f2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux%2f&title=How%20to%20wrap%20a%20system%20call%20%28libc%20function%29%20in%20Linux"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to wrap a system call (libc function) in Linux on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fsamanbarghi.com%2fpost%2f2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to wrap a system call (libc function) in Linux on whatsapp" href="https://api.whatsapp.com/send?text=How%20to%20wrap%20a%20system%20call%20%28libc%20function%29%20in%20Linux%20-%20http%3a%2f%2fsamanbarghi.com%2fpost%2f2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to wrap a system call (libc function) in Linux on telegram" href="https://telegram.me/share/url?text=How%20to%20wrap%20a%20system%20call%20%28libc%20function%29%20in%20Linux&url=http%3a%2f%2fsamanbarghi.com%2fpost%2f2014-09-05-how-to-wrap-a-system-call-libc-function-in-linux%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://samanbarghi.com/>Saman Barghi</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>